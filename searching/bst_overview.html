<p><a href="home.html">Main Page</a>  </p>
<h1>Balancing Search Trees</h1>
<h2>Balance and Efficiency</h2>
<p>A search tree is a lot like an extension of Indexed Sequential Search except that instead of using a few nested index tables to break up a larger array, there is an index table for each pair of records.</p>
<p>Recall the depiction of ISAM:  </p>
<p><img alt="Indexed Sequential Search" src="media/ind1.png# md" /></p>
<p>Using the ISAM analog, an unbalanced tree is like using a poor choice for the index table.<br />
A completely unbalanced tree will destroy the efficiencies of any search algorithm.  </p>
<figure>
  <p><img src="media/unbalanced.png"
    top=0px;
    left=400px;
    width="350" 
    alt="Unbalanced">
  <figcaption>Unbalanced Search Tree</figcaption>
</figure>

<p>In the unbalanced tree above, the only way to traverse the tree is by accessing each node sequentially.<br />
Searching in this manner will have the same properties as sequential search, that is (n+1)/2 comparisons and O(n) time complexity.</p>
<p>However, if the tree is balanced such that the height is minimized, significant gains in efficiency can be achieved.
In the tree example below, it only takes 4 comparisons to return the value 54, whereas in a completely unbalanced tree (or sorted array) it would take 8 comparisons.</p>
<figure>
  <p><img src="media/balanced.png"
    top=0px;
    left=0px;
    width="350" 
    alt="Balanced">
  <figcaption>Balanced Search Tree</figcaption>
</figure>

<p>Searches range from O(log n) to O(n) depending on how well a tree is balanced.</p>
<p>Next: <a href="searching.html">Overview of Searching</a><br />
<a href="home.html">Main Page</a>  </p>
<style type="text/css" rel="stylesheet">

img[src~="th"] {
   width:150px;
}
img[src~="thl"] {
    width:225px;
}
img[src~="bordered"] {
   border: 1px solid black;
}
img[src~="md"] {
   width:350px;
}
img[src~="mdl"] {
    width:500px;
}
img[src~="large"] {
   width:700px;
}
</style>